<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2-Approximating the Minimum Knapsack Problem | TAMREF's blog</title>
<meta name=keywords content="approximation-algorithm,linear-programming"><meta name=description content="Intro Definition. Given $n$ items labeled by $[n]$, and item $i$ has value $v_{i}$ and cost $c_{i}$, we define minimum knapsack problem as following optimization problem - integer programming in fact. $$ \begin{aligned} \text{minimize}\quad& \sum_{i} c_{i}x_{i} \\ \text{s.t.}\quad& \sum_{i} v_{i}x_{i} \ge D \\ & x_{i} \in \set{0, 1} \end{aligned} $$ where $D$ is given desire on value.
We can devise a naive LP relaxation for this: $$ \begin{aligned} \text{minimize}\quad& \sum_{i} c_{i}x_{i}\\ \text{s."><meta name=author content="TAMREF"><link rel=canonical href=https://tamref.github.io/posts/min-knapsack-2-approx/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tamref.github.io/assets/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tamref.github.io/assets/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tamref.github.io/assets/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://tamref.github.io/assets/favicon/apple-touch-icon.png><link rel=mask-icon href=https://tamref.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{"\\abs":`\\left\\lvert #1 \\right\\rvert`,"\\mc":"\\mathcal","\\mf":"\\mathfrak","\\mb":"\\mathbb","\\mar":"\\mathrm","\\mab":"\\mathbb","\\mr":"\\mathrm","\\ip":`\\left<#1, #2\\right>`,"\\set":`\\left\\lbrace #1 \\right\\rbrace`,"\\norm":`\\left\\lVert #1 \\right\\rVert`,"\\ev":`\\left<#1 \\right>`,"\\mex":"\\mathrm{mex}","\\nonneg":"\\mathbb{Z}_{\\ge 0}","\\pd":"\\partial","\\idx":"\\mathrm{idx}","\\im":"\\mathrm{im}","\\bs":"\\setminus","\\maf":"\\mathfrak","\\sz":`\\left\\lvert #1 \\right\\rvert`,"\\mbf":"\\mathbf"}})})</script><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="2-Approximating the Minimum Knapsack Problem"><meta property="og:description" content="Intro Definition. Given $n$ items labeled by $[n]$, and item $i$ has value $v_{i}$ and cost $c_{i}$, we define minimum knapsack problem as following optimization problem - integer programming in fact. $$ \begin{aligned} \text{minimize}\quad& \sum_{i} c_{i}x_{i} \\ \text{s.t.}\quad& \sum_{i} v_{i}x_{i} \ge D \\ & x_{i} \in \set{0, 1} \end{aligned} $$ where $D$ is given desire on value.
We can devise a naive LP relaxation for this: $$ \begin{aligned} \text{minimize}\quad& \sum_{i} c_{i}x_{i}\\ \text{s."><meta property="og:type" content="article"><meta property="og:url" content="https://tamref.github.io/posts/min-knapsack-2-approx/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-26T20:00:00+09:00"><meta property="article:modified_time" content="2023-12-26T20:00:00+09:00"><meta property="og:site_name" content="TAMREF's blog v2"><meta name=twitter:card content="summary"><meta name=twitter:title content="2-Approximating the Minimum Knapsack Problem"><meta name=twitter:description content="Intro Definition. Given $n$ items labeled by $[n]$, and item $i$ has value $v_{i}$ and cost $c_{i}$, we define minimum knapsack problem as following optimization problem - integer programming in fact. $$ \begin{aligned} \text{minimize}\quad& \sum_{i} c_{i}x_{i} \\ \text{s.t.}\quad& \sum_{i} v_{i}x_{i} \ge D \\ & x_{i} \in \set{0, 1} \end{aligned} $$ where $D$ is given desire on value.
We can devise a naive LP relaxation for this: $$ \begin{aligned} \text{minimize}\quad& \sum_{i} c_{i}x_{i}\\ \text{s."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tamref.github.io/posts/"},{"@type":"ListItem","position":2,"name":"2-Approximating the Minimum Knapsack Problem","item":"https://tamref.github.io/posts/min-knapsack-2-approx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2-Approximating the Minimum Knapsack Problem","name":"2-Approximating the Minimum Knapsack Problem","description":"Intro Definition. Given $n$ items labeled by $[n]$, and item $i$ has value $v_{i}$ and cost $c_{i}$, we define minimum knapsack problem as following optimization problem - integer programming in fact. $$ \\begin{aligned} \\text{minimize}\\quad\u0026amp; \\sum_{i} c_{i}x_{i} \\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{i} v_{i}x_{i} \\ge D \\\\ \u0026amp; x_{i} \\in \\set{0, 1} \\end{aligned} $$ where $D$ is given desire on value.\nWe can devise a naive LP relaxation for this: $$ \\begin{aligned} \\text{minimize}\\quad\u0026amp; \\sum_{i} c_{i}x_{i}\\\\ \\text{s.","keywords":["approximation-algorithm","linear-programming"],"articleBody":"Intro Definition. Given $n$ items labeled by $[n]$, and item $i$ has value $v_{i}$ and cost $c_{i}$, we define minimum knapsack problem as following optimization problem - integer programming in fact. $$ \\begin{aligned} \\text{minimize}\\quad\u0026 \\sum_{i} c_{i}x_{i} \\\\ \\text{s.t.}\\quad\u0026 \\sum_{i} v_{i}x_{i} \\ge D \\\\ \u0026 x_{i} \\in \\set{0, 1} \\end{aligned} $$ where $D$ is given desire on value.\nWe can devise a naive LP relaxation for this: $$ \\begin{aligned} \\text{minimize}\\quad\u0026 \\sum_{i} c_{i}x_{i}\\\\ \\text{s.t.}\\quad\u0026 \\sum_{i} v_{i}x_{i} \\ge D\\\\ \u0026 x_{i} \\in [0, 1] \\end{aligned} $$ while this can be as bad as $D$ in terms of approximation ratio. Where $v_{1} = D-1, v_{2} = D$ and $c_{1} = 0, c_{2} = D$, LP optimum is $1$ where $x = (1, \\frac{1}{D})$ but the IP optimum is $D$ for $x = (0, 1)$.\nHowever, adopting additional LP constraints provides a significant improvement on performance. Assume that for a set $A \\subseteq [n]$, we added all items in $A$ for our collection. Then, it should be satisfied in the Integer Program. They are referred to knapsack covering inequalities. $$ \\sum_{i \\notin A} \\min(D - v(A), v_{i}) x_{i} \\ge D - v(A) $$ Where $v(A) := \\sum_{i \\in A} v_{i}$ is sum of the value of items in $A$. Now we can re-write the LP relaxation as below. $$ \\begin{aligned} \\text{minimize}\\quad\u0026 \\sum_{i} c_{i}x_{i} \\\\ \\text{s.t.}\\quad\u0026 \\sum_{i \\in [n] \\setminus A} v_{i}^{-A}x_{i} \\ge D - v(A) \u0026 \\forall A \\subseteq [n] \\\\ \u0026 x_{i} \\in [0, 1] \\end{aligned} $$ Where $v_{i}^{-A} := \\min(v_{i}, D - v(A))$. We will prove in two ways, that this LP gives 2-approximation of Minimum Knapsack Problem, and address the way dealing with exponentially many conditions.\nSimple Primal-Dual solution The simplest way is considering the dual program. $$ \\begin{aligned} \\text{maximize}\\quad\u0026 \\sum_{i} (D - v(A))y_{A}\\\\ \\text{s.t.}\\quad\u0026 \\sum_{i \\in [n] \\setminus A} v_{i}^{-A}y_{A} \\le c_{i} \u0026 \\forall i \\in [n]\\\\ \u0026 y_{A} \\ge 0 \\end{aligned} $$ Note that the Primal Complementary Slackness condition $$ x_{i} \u003e 0 \\implies c_{i} = \\sum_{i \\in [n] \\setminus A} v_{i}^{-A}y_{A} $$ Will guide us to the derivation. We execute the dual algorithm as follows.\nSet $B := \\emptyset$. While $v(B) \u003c D$: Increase $y_{B}$ until an inequality becomes tight. If an inequality for item $j$ became tight, add $j$ into $B$. Return $B$. The algorithm maintains a valid dual solution, since once $j$ is added into $B$ no dual variables in constraint for item $j$ grow up. It’ll terminate in $O(n^{2})$ time. Now, let’s verify the performance.\nApproximation ratio Note that we set the primal / dual pair to satisfy the complementary slackness condition. Now using the complementary slackness condition, we expand the cost term. $$ \\sum_{i \\in B} c_{i} x_{i} = \\sum_{i \\in B} x_{i} \\sum_{i \\in [n] \\setminus A} v_{i}^{-A} y_{A} = \\sum_{A \\subseteq B} y_{A} \\sum_{i \\in B \\setminus A} v_{i}^{-A} $$ Note that $y_{A} = 0$ for $A \\not\\subseteq B$ . Specifically, $y_{A}$ will be positive for only (proper) prefix set of $(a_{1}, \\cdots, a_{k})$, the trace of elements added into $A$. Fix a set $A$, and let $l$ be the latest element added to $B$. It will be always in $B \\subseteq A$. Since $v(B) - v_{l} \u003c D$, We can say that $v(B) - v(A) - v_{l} \u003c D - v(A)$ hence for all $t \\in B \\setminus A \\setminus l$, $v_{t} = v_{t}^{-A}$.\nCombining this, we obtain $\\sum_{i \\in B \\setminus A} v_{i}^{-A} = v_{l}^{-A} + \\sum_{i \\in B \\setminus A \\setminus l} v_{i} = (v(B) - v_{l} - v(A)) + v_{l}^{-A} \u003c 2(D - v(A))$. Thus we can say that $$ \\sum_{i \\in B} c_{i} \\le 2 \\sum_{A \\subseteq B} y_{A} (D - v(A)) \\le 2 \\mathrm{OPT}. $$\nSolution from rounding Primal-dual is a constructive proof of 2-approximation. Via LP rounding, we will achieve stronger result.\nClaim. For any feasible solution $x$ of knapsack covering LP, there is a set of feasible integral solutions $x^{(1)}, \\cdots, x^{(t)}$, which accepts a convex combination dominated by $2x$. i.e. there is a non-negative coefficient $\\lambda^{(i)} \\ge 0$ such that $\\sum_{i = 1}^{t} \\lambda^{(i)}x^{(i)} \\le 2x$, and $\\sum_{i} \\lambda^{(i)} = 1$.\nThis is clearly a generalization of 2-approximation result if we set $x$ as the optimum of knapsack covering LP. But how do we solve this LP, having exponentially many constraints?\nThere are some known methods as ellipsoid methods provided by poly-time separation oracle, but it is not that easy to obtain such oracle as well. Here, we delve into the Claim and obtain the poly-time solution using the separation-oracle based on ellipsoid method.\nProof of claim We assume the coefficients are all integer, and $x$ is a rational vector. Suppose that for an integer $r \u003e 0$, $rx$ is integral. We will set $r$ buckets on a circle, and assign items to each bucket. Assume $A := \\set{i : x_{i} \\ge 1/2}$. For items in $[n] \\setminus A$, we renumber the items to $1, \\cdots, k$ so that $v_{1} \\ge \\cdots \\ge v_{k}$. Starting from the item 1, we distribute $2rx_{i}$ copies of item $i$ to each bucket, going clockwise through the circle. Note that an item will never be put into the same bucket as $2rx_{i} \u003c 2r \\cdot \\frac{1}{2} = r$. Now, we claim that each bucket generates a feasible integral solution combined with $A$. It suffices to see the last ($r$-th) bucket $K$ which will have the least value. If $\\sum_{i \\in K} v_{i}^{-A} \u003c D - v(A)$, we will show that $\\sum_{i \\in F} v_{i}^{-A} \u003c 2 (D - v(A))$ for the first bucket $F$. And then, it contradicts to the fact that average value of all the bucket is $ \\frac{1}{r}\\sum_{i = 1}^{k} (2rx_{i})v_{i}^{-A} = 2 \\sum_{i = 1}^{r} v_{i}^{-A}x_{i} \\ge 2(D - v(A)) $ from the knapsack feasibility of $x$.\nNote that $v_{i}^{-A} \\ge v_{j}^{-A}$ if $i \u003c j$. So $\\sum_{i \\in F} v_{i}^{-A} - \\sum_{i \\in K} v_{i}^{-A}$ is sum of a non-increasing alternating sequence of which starting term is not greater than $D - v(A)$; thus also bounded by $D - v(A)$. $\\square$\nSome readers might’ve noticed that the “bucket distribution” involves only $k$ distinct budgets, so it’s able to construct such bucket in polynomial time.\nSolving an exponentially sized LP Actually, we’ll restrain from solving the entire LP to obtain the optimum of knapsack covering LP. From the proof of claim, we noticed that the solution $x$ suffices, if it satisfies knapsack-covering inequality for the set $ A_{x} := \\set{i\\in [n] : x_{i} \\ge 1/2}. $ provided the cost of $x$ is better than the optimal cost of knapsack covering LP. We’ll proceed the ellipsoid algorithm as follows:\nStart from a random solution $x$ and a large enough ellipsoid centered at $x$. If $x$ satisfies the knapsack covering inequality for $A_{x}$, cut the ellipsoid by the half-plane $\\set{y : c^{T}y \\le c^{T}x }$. If $x$ violates, we got the separation oracle. It’s provided that the algorithm terminates in the polynomial time, finding or failed to finding an optimal (basic) point $x_{0}$ satisfying knapsack covering inequality respect to $A_{x_0}$. We call a solution $x$ a self-covering solution if $x$ satisfies $A_{x}$ knapsack-covering inequality.\nIf the algorithm ended up failing to find any single self-covering solution, we conclude that the polytope is empty, since the ellipsoid must be shrunken enough. Otherwise, the last self-covering solution and the following violations guarantees that there is no feasible solution of full knapsack-covering LP with better cost compared to it. Either way, we proved that our algorithm gives the desired result. As a side note, set of self-covering solution is not necessarily convex, considering the form of constraint.\nReferences Williamson, David P., and David B. Shmoys. The design of approximation algorithms. Cambridge university press, 2011. For primal-dual approach. Carr, Robert D., et al. Strengthening integrality gaps for capacitated network design and covering problems. No. SAND99-1972C. Sandia National Lab.(SNL-NM), Albuquerque, NM (United States); Sandia National Lab.(SNL-CA), Livermore, CA (United States), 1999. For rounding approach. Grötschel, Martin, László Lovász, and Alexander Schrijver. Geometric algorithms and combinatorial optimization. Vol. 2. Springer Science \u0026 Business Media, 2012. ","wordCount":"1333","inLanguage":"en","datePublished":"2023-12-26T20:00:00+09:00","dateModified":"2023-12-26T20:00:00+09:00","author":{"@type":"Person","name":"TAMREF"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamref.github.io/posts/min-knapsack-2-approx/"},"publisher":{"@type":"Organization","name":"TAMREF's blog","logo":{"@type":"ImageObject","url":"https://tamref.github.io/assets/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamref.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tamref.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamref.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tamref.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://tamref.com title="My tistory blog"><span>My tistory blog</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamref.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tamref.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">2-Approximating the Minimum Knapsack Problem</h1><div class=post-meta><span title='2023-12-26 20:00:00 +0900 KST'>December 26, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1333 words&nbsp;·&nbsp;TAMREF&nbsp;|&nbsp;<a href=https://github.com/TAMREF/tam_hugo/posts/min-knapsack-2-approx.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p><strong>Definition.</strong> Given $n$ items labeled by $[n]$, and item $i$ has value $v_{i}$ and cost $c_{i}$, we define minimum knapsack problem as following optimization problem - integer programming in fact.
$$
\begin{aligned}
\text{minimize}\quad& \sum_{i} c_{i}x_{i} \\
\text{s.t.}\quad& \sum_{i} v_{i}x_{i} \ge D \\
& x_{i} \in \set{0, 1}
\end{aligned}
$$
where $D$ is given desire on value.</p><p>We can devise a naive LP relaxation for this:
$$
\begin{aligned}
\text{minimize}\quad& \sum_{i} c_{i}x_{i}\\
\text{s.t.}\quad& \sum_{i} v_{i}x_{i} \ge D\\
& x_{i} \in [0, 1]
\end{aligned}
$$
while this can be as bad as $D$ in terms of approximation ratio.
Where $v_{1} = D-1, v_{2} = D$ and $c_{1} = 0, c_{2} = D$, LP optimum is $1$ where $x = (1, \frac{1}{D})$ but the IP optimum is $D$ for $x = (0, 1)$.</p><p>However, adopting additional LP constraints provides a significant improvement on performance.
Assume that for a set $A \subseteq [n]$, we added all items in $A$ for our collection. Then, it should be satisfied in the Integer Program. They are referred to <strong>knapsack covering inequalities</strong>.
$$
\sum_{i \notin A} \min(D - v(A), v_{i}) x_{i} \ge D - v(A)
$$
Where $v(A) := \sum_{i \in A} v_{i}$ is sum of the value of items in $A$.
Now we can re-write the LP relaxation as below.
$$
\begin{aligned}
\text{minimize}\quad& \sum_{i} c_{i}x_{i} \\
\text{s.t.}\quad& \sum_{i \in [n] \setminus A} v_{i}^{-A}x_{i} \ge D - v(A) & \forall A \subseteq [n] \\
& x_{i} \in [0, 1]
\end{aligned}
$$
Where $v_{i}^{-A} := \min(v_{i}, D - v(A))$.
We will prove in two ways, that this LP gives <strong>2-approximation</strong> of Minimum Knapsack Problem, and address the way dealing with exponentially many conditions.</p><h2 id=simple-primal-dual-solution>Simple Primal-Dual solution<a hidden class=anchor aria-hidden=true href=#simple-primal-dual-solution>#</a></h2><p>The simplest way is considering the dual program.
$$
\begin{aligned}
\text{maximize}\quad& \sum_{i} (D - v(A))y_{A}\\
\text{s.t.}\quad& \sum_{i \in [n] \setminus A} v_{i}^{-A}y_{A} \le c_{i} & \forall i \in [n]\\
& y_{A} \ge 0
\end{aligned}
$$
Note that the Primal Complementary Slackness condition
$$
x_{i} > 0 \implies c_{i} = \sum_{i \in [n] \setminus A} v_{i}^{-A}y_{A}
$$
Will guide us to the derivation. We execute the dual algorithm as follows.</p><ul><li>Set $B := \emptyset$.</li><li>While $v(B) &lt; D$:<ul><li>Increase $y_{B}$ until an inequality becomes tight.</li><li>If an inequality for item $j$ became tight, add $j$ into $B$.</li></ul></li><li>Return $B$.</li></ul><p>The algorithm maintains a valid dual solution, since once $j$ is added into $B$ no dual variables in constraint for item $j$ grow up. It&rsquo;ll terminate in $O(n^{2})$ time. Now, let&rsquo;s verify the performance.</p><h3 id=approximation-ratio>Approximation ratio<a hidden class=anchor aria-hidden=true href=#approximation-ratio>#</a></h3><p>Note that we set the primal / dual pair to satisfy the complementary slackness condition.
Now using the complementary slackness condition, we expand the cost term.
$$
\sum_{i \in B} c_{i} x_{i} = \sum_{i \in B} x_{i} \sum_{i \in [n] \setminus A} v_{i}^{-A} y_{A} = \sum_{A \subseteq B} y_{A} \sum_{i \in B \setminus A} v_{i}^{-A}
$$
Note that $y_{A} = 0$ for $A \not\subseteq B$ . Specifically, $y_{A}$ will be positive for only (proper) prefix set of $(a_{1}, \cdots, a_{k})$, the trace of elements added into $A$.
Fix a set $A$, and let $l$ be the latest element added to $B$. It will be always in $B \subseteq A$. Since $v(B) - v_{l} &lt; D$, We can say that $v(B) - v(A) - v_{l} &lt; D - v(A)$ hence for all $t \in B \setminus A \setminus l$, $v_{t} = v_{t}^{-A}$.</p><p>Combining this, we obtain
$\sum_{i \in B \setminus A} v_{i}^{-A} = v_{l}^{-A} + \sum_{i \in B \setminus A \setminus l} v_{i} = (v(B) - v_{l} - v(A)) + v_{l}^{-A} &lt; 2(D - v(A))$.
Thus we can say that
$$
\sum_{i \in B} c_{i} \le 2 \sum_{A \subseteq B} y_{A} (D - v(A)) \le 2 \mathrm{OPT}.
$$</p><h2 id=solution-from-rounding>Solution from rounding<a hidden class=anchor aria-hidden=true href=#solution-from-rounding>#</a></h2><p>Primal-dual is a constructive proof of 2-approximation. Via LP rounding, we will achieve stronger result.</p><p><strong>Claim.</strong> For any feasible solution $x$ of knapsack covering LP, there is a set of feasible integral solutions $x^{(1)}, \cdots, x^{(t)}$, which accepts a convex combination dominated by $2x$. i.e. there is a non-negative coefficient $\lambda^{(i)} \ge 0$ such that $\sum_{i = 1}^{t} \lambda^{(i)}x^{(i)} \le 2x$, and $\sum_{i} \lambda^{(i)} = 1$.</p><p>This is clearly a generalization of 2-approximation result if we set $x$ as the optimum of knapsack covering LP. But how do we solve this LP, having exponentially many constraints?</p><p>There are some known methods as ellipsoid methods provided by poly-time separation oracle, but it is not that easy to obtain such oracle as well. Here, we delve into the <strong>Claim</strong> and obtain the poly-time solution using the separation-oracle based on ellipsoid method.</p><h3 id=proof-of-claim>Proof of claim<a hidden class=anchor aria-hidden=true href=#proof-of-claim>#</a></h3><p>We assume the coefficients are all integer, and $x$ is a rational vector. Suppose that for an integer $r > 0$, $rx$ is integral. We will set $r$ buckets on a circle, and assign items to each bucket.
Assume $A := \set{i : x_{i} \ge 1/2}$. For items in $[n] \setminus A$, we renumber the items to $1, \cdots, k$ so that $v_{1} \ge \cdots \ge v_{k}$. Starting from the item 1, we distribute $2rx_{i}$ copies of item $i$ to each bucket, going clockwise through the circle. Note that an item will never be put into the same bucket as $2rx_{i} &lt; 2r \cdot \frac{1}{2} = r$.
Now, we claim that each bucket generates a feasible integral solution combined with $A$. It suffices to see the last ($r$-th) bucket $K$ which will have the least value. If $\sum_{i \in K} v_{i}^{-A} &lt; D - v(A)$, we will show that $\sum_{i \in F} v_{i}^{-A} &lt; 2 (D - v(A))$ for the first bucket $F$. And then, it contradicts to the fact that average value of all the bucket is
$
\frac{1}{r}\sum_{i = 1}^{k} (2rx_{i})v_{i}^{-A} = 2 \sum_{i = 1}^{r} v_{i}^{-A}x_{i} \ge 2(D - v(A))
$
from the knapsack feasibility of $x$.</p><p>Note that $v_{i}^{-A} \ge v_{j}^{-A}$ if $i &lt; j$.
So $\sum_{i \in F} v_{i}^{-A} - \sum_{i \in K} v_{i}^{-A}$ is sum of a non-increasing alternating sequence of which starting term is not greater than $D - v(A)$; thus also bounded by $D - v(A)$. $\square$</p><p>Some readers might&rsquo;ve noticed that the &ldquo;bucket distribution&rdquo; involves only $k$ distinct budgets, so it&rsquo;s able to construct such bucket in polynomial time.</p><h3 id=solving-an-exponentially-sized-lp>Solving an exponentially sized LP<a hidden class=anchor aria-hidden=true href=#solving-an-exponentially-sized-lp>#</a></h3><p>Actually, we&rsquo;ll restrain from solving the entire LP to obtain the optimum of knapsack covering LP. From the proof of claim, we noticed that the solution $x$ suffices, if it satisfies knapsack-covering inequality for the set
$
A_{x} := \set{i\in [n] : x_{i} \ge 1/2}.
$
provided the cost of $x$ is better than the optimal cost of knapsack covering LP. We&rsquo;ll proceed the ellipsoid algorithm as follows:</p><ul><li>Start from a random solution $x$ and a large enough ellipsoid centered at $x$.<ul><li>If $x$ satisfies the knapsack covering inequality for $A_{x}$, cut the ellipsoid by the half-plane $\set{y : c^{T}y \le c^{T}x }$.</li><li>If $x$ violates, we got the separation oracle.</li></ul></li></ul><p>It&rsquo;s provided that the algorithm terminates in the polynomial time, finding or failed to finding an optimal (basic) point $x_{0}$ satisfying knapsack covering inequality respect to $A_{x_0}$.
We call a solution $x$ a <strong>self-covering solution</strong> if $x$ satisfies $A_{x}$ knapsack-covering inequality.</p><ul><li>If the algorithm ended up failing to find any single <strong>self-covering solution</strong>, we conclude that the polytope is empty, since the ellipsoid must be shrunken enough.</li><li>Otherwise, the last <strong>self-covering solution</strong> and the following violations guarantees that there is <strong>no feasible solution of full knapsack-covering LP</strong> with better cost compared to it.</li></ul><p>Either way, we proved that our algorithm gives the desired result.
As a side note, set of self-covering solution is not necessarily convex, considering the form of constraint.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>Williamson, David P., and David B. Shmoys. <em>The design of approximation algorithms</em>. Cambridge university press, 2011.<ul><li>For primal-dual approach.</li></ul></li><li>Carr, Robert D., et al. <em>Strengthening integrality gaps for capacitated network design and covering problems</em>. No. SAND99-1972C. Sandia National Lab.(SNL-NM), Albuquerque, NM (United States); Sandia National Lab.(SNL-CA), Livermore, CA (United States), 1999.<ul><li>For rounding approach.</li></ul></li><li>Grötschel, Martin, László Lovász, and Alexander Schrijver. <em>Geometric algorithms and combinatorial optimization</em>. Vol. 2. Springer Science & Business Media, 2012.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tamref.github.io/tags/approximation-algorithm/>approximation-algorithm</a></li><li><a href=https://tamref.github.io/tags/linear-programming/>linear-programming</a></li></ul><nav class=paginav><a class=next href=https://tamref.github.io/posts/migrated/alexander-duality/><span class=title>Next »</span><br><span>Alexander Duality</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on x" href="https://x.com/intent/tweet/?text=2-Approximating%20the%20Minimum%20Knapsack%20Problem&amp;url=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f&amp;hashtags=approximation-algorithm%2clinear-programming"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f&amp;title=2-Approximating%20the%20Minimum%20Knapsack%20Problem&amp;summary=2-Approximating%20the%20Minimum%20Knapsack%20Problem&amp;source=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f&title=2-Approximating%20the%20Minimum%20Knapsack%20Problem"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on whatsapp" href="https://api.whatsapp.com/send?text=2-Approximating%20the%20Minimum%20Knapsack%20Problem%20-%20https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on telegram" href="https://telegram.me/share/url?text=2-Approximating%20the%20Minimum%20Knapsack%20Problem&amp;url=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2-Approximating the Minimum Knapsack Problem on ycombinator" href="https://news.ycombinator.com/submitlink?t=2-Approximating%20the%20Minimum%20Knapsack%20Problem&u=https%3a%2f%2ftamref.github.io%2fposts%2fmin-knapsack-2-approx%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tamref.github.io/>TAMREF's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>