<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ps_20220716 | TAMREF's blog</title>
<meta name=keywords content><meta name=description content="교육용으로 사용한 10문제의 풀이입니다. 용어가 원본 문제와 다를 수 있습니다.
BAPC 2021 F. &ldquo;Fair Play&rdquo; $n$이 홀수인 경우는 당연히 불가능하고, 짝수인 경우 $(b, p)$를 std::pair 와 같은 방식으로 정렬한 것을 $(b_{1}, p_{1}), \cdots, (b_{n}, p_{n})$이라고 둡시다. 이 때 유일하게 가능한 매칭 방법은 $(b_{1}, p_{1})$을 $(b_{n}, p_{n})$과, $(b_{2}, p_{2})$를 $(b_{n-1}, p_{n-1})$과 &mldr; 매칭해주는 것입니다. 이렇게 해서 벡터합이 모두 균일하다면 possible, 그렇지 않다면 impossible 입니다.
BAPC 2021 I &ldquo;Implementation Irregularities&rdquo; $s_{i}$가 증가하는 순서대로 원소들을 배열하고, $s_{i} = -1$인 원소들을 제외합시다."><meta name=author content="TAMREF"><link rel=canonical href=https://tamref.github.io/posts/migrated/ps_20220716/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://tamref.github.io/assets/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tamref.github.io/assets/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tamref.github.io/assets/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://tamref.github.io/assets/favicon/apple-touch-icon.png><link rel=mask-icon href=https://tamref.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{"\\abs":`\\left\\lvert #1 \\right\\rvert`,"\\mc":"\\mathcal","\\mf":"\\mathfrak","\\mb":"\\mathbb","\\mar":"\\mathrm","\\mab":"\\mathbb","\\mr":"\\mathrm","\\ip":`\\left<#1, #2\\right>`,"\\set":`\\left\\lbrace #1 \\right\\rbrace`}})})</script><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Ps_20220716"><meta property="og:description" content="교육용으로 사용한 10문제의 풀이입니다. 용어가 원본 문제와 다를 수 있습니다.
BAPC 2021 F. &ldquo;Fair Play&rdquo; $n$이 홀수인 경우는 당연히 불가능하고, 짝수인 경우 $(b, p)$를 std::pair 와 같은 방식으로 정렬한 것을 $(b_{1}, p_{1}), \cdots, (b_{n}, p_{n})$이라고 둡시다. 이 때 유일하게 가능한 매칭 방법은 $(b_{1}, p_{1})$을 $(b_{n}, p_{n})$과, $(b_{2}, p_{2})$를 $(b_{n-1}, p_{n-1})$과 &mldr; 매칭해주는 것입니다. 이렇게 해서 벡터합이 모두 균일하다면 possible, 그렇지 않다면 impossible 입니다.
BAPC 2021 I &ldquo;Implementation Irregularities&rdquo; $s_{i}$가 증가하는 순서대로 원소들을 배열하고, $s_{i} = -1$인 원소들을 제외합시다."><meta property="og:type" content="article"><meta property="og:url" content="https://tamref.github.io/posts/migrated/ps_20220716/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-26T17:02:49+09:00"><meta property="article:modified_time" content="2023-12-26T17:02:49+09:00"><meta property="og:site_name" content="TAMREF's blog v2"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ps_20220716"><meta name=twitter:description content="교육용으로 사용한 10문제의 풀이입니다. 용어가 원본 문제와 다를 수 있습니다.
BAPC 2021 F. &ldquo;Fair Play&rdquo; $n$이 홀수인 경우는 당연히 불가능하고, 짝수인 경우 $(b, p)$를 std::pair 와 같은 방식으로 정렬한 것을 $(b_{1}, p_{1}), \cdots, (b_{n}, p_{n})$이라고 둡시다. 이 때 유일하게 가능한 매칭 방법은 $(b_{1}, p_{1})$을 $(b_{n}, p_{n})$과, $(b_{2}, p_{2})$를 $(b_{n-1}, p_{n-1})$과 &mldr; 매칭해주는 것입니다. 이렇게 해서 벡터합이 모두 균일하다면 possible, 그렇지 않다면 impossible 입니다.
BAPC 2021 I &ldquo;Implementation Irregularities&rdquo; $s_{i}$가 증가하는 순서대로 원소들을 배열하고, $s_{i} = -1$인 원소들을 제외합시다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tamref.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Ps_20220716","item":"https://tamref.github.io/posts/migrated/ps_20220716/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ps_20220716","name":"Ps_20220716","description":"교육용으로 사용한 10문제의 풀이입니다. 용어가 원본 문제와 다를 수 있습니다.\nBAPC 2021 F. \u0026ldquo;Fair Play\u0026rdquo; $n$이 홀수인 경우는 당연히 불가능하고, 짝수인 경우 $(b, p)$를 std::pair 와 같은 방식으로 정렬한 것을 $(b_{1}, p_{1}), \\cdots, (b_{n}, p_{n})$이라고 둡시다. 이 때 유일하게 가능한 매칭 방법은 $(b_{1}, p_{1})$을 $(b_{n}, p_{n})$과, $(b_{2}, p_{2})$를 $(b_{n-1}, p_{n-1})$과 \u0026hellip; 매칭해주는 것입니다. 이렇게 해서 벡터합이 모두 균일하다면 possible, 그렇지 않다면 impossible 입니다.\nBAPC 2021 I \u0026ldquo;Implementation Irregularities\u0026rdquo; $s_{i}$가 증가하는 순서대로 원소들을 배열하고, $s_{i} = -1$인 원소들을 제외합시다.","keywords":[],"articleBody":"교육용으로 사용한 10문제의 풀이입니다. 용어가 원본 문제와 다를 수 있습니다.\nBAPC 2021 F. “Fair Play” $n$이 홀수인 경우는 당연히 불가능하고, 짝수인 경우 $(b, p)$를 std::pair 와 같은 방식으로 정렬한 것을 $(b_{1}, p_{1}), \\cdots, (b_{n}, p_{n})$이라고 둡시다. 이 때 유일하게 가능한 매칭 방법은 $(b_{1}, p_{1})$을 $(b_{n}, p_{n})$과, $(b_{2}, p_{2})$를 $(b_{n-1}, p_{n-1})$과 … 매칭해주는 것입니다. 이렇게 해서 벡터합이 모두 균일하다면 possible, 그렇지 않다면 impossible 입니다.\nBAPC 2021 I “Implementation Irregularities” $s_{i}$가 증가하는 순서대로 원소들을 배열하고, $s_{i} = -1$인 원소들을 제외합시다. 이 때 답은 $\\max_{i} \\lceil \\frac{t_{1} + \\cdots + t_{i}}{s_{i}} \\rceil$가 됩니다.\n2021/2022 COCI Contest #2 B “Kutije” 한 순열 $p(1), \\cdots, p(n)$에 대해 $i$번 정점과 $p(i)$번 정점을 간선으로 이어주면, 이는 사이클 몇 개로 분할되는 그래프를 이룹니다. 결국 주어지는 쿼리는 $a, b$가 같은 연결컴포넌트에 있는지를 물어보는 것이고, 사전에 DFS, union-find를 통해 컴포넌트를 구해두면 쿼리당 $O(1)$에 해결할 수 있습니다.\nCERC 2015 K “Kernel Knights” Indegree가 0인 정점 $a$는 무조건 선택해야 하고, 따라서 $f_{a}$는 무조건 배제해야 합니다. 이제 전체 그래프에서 $a, f_{a}$를 제외한 뒤 같은 과정을 반복하면 최종적으로 아무 정점도 남지 않거나, cycle이 남게 됩니다. 그래프가 이분그래프이기 때문에 이는 짝수 길이 cycle이 되고, 이 중에서는 범위($[1, N]$ 혹은 $[N+1, 2N]$)가 같은 점들만 골라주면 됩니다.\n2020 Jakarta Regional J “Token Distance” 좀 더 쉬운 버전인, 어떤 구간 $[s, e]$를 정렬했을 때 $\\set{x, x + 1, \\cdots, x + e - s}$가 될 필요충분조건을 생각해 봅시다.\n구간 $[s, e]$의 최댓값 - 최솟값이 정확히 $e - s$이다. 구간 $[s, e]$에 중복 원소가 존재하지 않는다. 하지만 일반적으로 $\\set{x, x + g, \\cdots, x + g (e - s)}$를 이룰 조건은 위 두개만으론 불충분합니다. 이 때 다음이 성립합니다.\nProposition. 구간 $[s, e]$의 수를 $A_{s}, \\cdots, A_{e}$라고 하자. 다음 세 조건을 동시에 만족하는 것과, $\\set{A_{s}, \\cdots, A_{e}} = \\set{x, x + g, \\cdots, x + g(e-s)}$가 성립하는 것은 동치이다.\n$\\max(A_{s}, \\cdots, A_{e}) - \\min(A_{s}, \\cdots, A_{e}) = g(e-s)$. $A_{s}, \\cdots, A_{e}$중 중복되는 값이 존재하지 않는다. $\\gcd(A_{s} - A_{s+1}, A_{s+1} - A_{s+2}, \\cdots, A_{e-1} - A_{e}) = g$. $\\set{A_{s}, \\cdots, A_{e}} = \\set{x, \\cdots, x + g(e-s)}$가 성립하는 경우 $\\gcd$ 조건을 만족하게 됩니다. $\\gcd$는 $g$의 배수가 될 것이고, 정확히 $g$가 아니면 $A_{s} \\pm g$가 등장할 수 없기 때문입니다. 또한 $\\gcd$ 조건을 만족하는 수열은 모두 $\\set{x, \\cdots, x + g(e-s)}$의 재배열뿐입니다.\n위 세가지 조건은 모두 Segment Tree 등을 이용해 판별할 수 있고, 시간복잡도는 $O(N \\log N)$이 됩니다.\n2021/2022 COCI Contest #2 E “Osumnjičeni” 주어진 $i$에 대해서, 구간 $[L_{i}, R_{i}], \\cdots, [L_{j}, R_{j}]$가 서로소가 되는 $j$의 최댓값을 미리 구해두고, 이를 $p(i)$라고 합시다. $p(i)$는 two-pointer로 $O(N\\log N)$ 시간에 구할 수 있습니다.\n$p^{0}(i) = i, p^{k}(i) = p(p^{k-1}(i))$로 정의하면, $[s, e]$ 형태로 쿼리가 들어올 경우 답은 $p^{k}(s) \\ge e$를 만족하는 $k$의 최솟값이 됩니다. 이는 $p^{k}(i)$를 sparse table 등으로 구해두면 $O(N \\log N + Q \\log N)$ 시간에 해결할 수 있습니다.\nDMOPC ‘21 Contest #7 Problem 5, “King’s Commands” 보다 간단한 경우로 $\\deg(a, 0) + \\deg(a, 1) \\le 1$인 경우를 생각해 봅시다. 연결 컴포넌트의 개수는 Degree가 0인 정점 (lone vertex)의 수와 선분들의 연결 컴포넌트 개수의 합으로 나타낼 수 있습니다.\n만약 $\\deg(a, 0) + \\deg(a, 1) \\le 1$이라면, lone vertex의 수는 상수로 유지되는 것을 알 수 있습니다. 따라서 선분들의 컴포넌트 수를 최소화하는 데만 집중하면 됩니다.\n$(l, 0), (r, 1)$을 잇는 선분을 $[l, r]$로 표기합시다. (편의상 $l \\le r$을 가정합니다) 만약 $l’ \\le l \\le r \\le r’$을 만족하는 $[l’, r’]$이 존재할 경우 $[l, r]$은 어떻게 놓아도 $[l’, r’]$과 이어지므로 신경쓰지 않아도 됩니다. 따라서 모든 선분들을 $l$ 순으로 정렬한 것을 $[l_{1}, r_{1}], \\cdots, [l_{n}, r_{n}]$이라고 두면 $r_{1} \u003c r_{2} \u003c \\cdots \u003c r_{n}$을 가정할 수 있습니다. 마찬가지로 $l_{1} \u003c l_{2} \u003c \\cdots \u003c l_{n}$ 또한 가정할 수 있습니다.\n만약 $r_{k} \\lt l_{k+1}$이라면 어떻게 하더라도 두 선분 $[l_{k}, r_{k}]$와 $[l_{k+1}, r_{k+1}]$을 이을 수 없고, $r_{k} \u003e l_{k+1}$이라면 둘을 엇갈리게 놓아서 연결할 수 있습니다.\n이제 본 문제를 해결해 봅시다. 차수가 2인 경우에는 간선을 어떻게 배치하느냐에 따라 lone vertex의 수가 달라질 수 있습니다. 이 때 간선들을 bottom vertex에 따라 정렬하고, 연속한 간선들을 group $G_{1}, G_{2}, \\cdots, G_{k}$로 최대한 쪼갭시다. 이 때 모든 $1 \\le i \\lt k$에 대해 $G_{1}, \\cdots, G_{i}$의 top vertex 중 가장 오른쪽에 있는 것이 $G_{i+1}, \\cdots, G_{k}$의 top vertex 중 가장 왼쪽에 있는 것보다 작거나 같아야 합니다. 이 때 각 group의 간선들은 차수 2인 정점 없이, 모두 연결되도록 할 수 있습니다. group $G_{i}$까지 모두 연결되도록 했을 때, 어떤 정점 $x$가 존재하여 $G_{i}$의 간선과 $G_{i+1}$의 간선에 모두 연결된다고 합시다. 이 경우 $G_{1}, \\cdots, G_{i}$를 모두 뒤집어주면 컴포넌트의 개수는 최대 1 감소하는 반면, lone vertex의 수는 확실히 1 감소하여 답이 줄어들지 않습니다.\n즉, 답이 $k$인 간선 배치가 주어지면 답이 $k$ 이상이고 차수 2인 정점이 없는 배치를 만들 수 있으므로, 우리는 차수 2인 정점이 없는 배치 중 컴포넌트 갯수가 가장 적은 배치를 찾을 것입니다.\n어떤 점 $(a, 0), (a, 1)$에 연결된 간선이 2개라면, 두 간선이 연결된 점은 달라야 합니다. 모든 정점 $(a, \\ast)$의 차수가 $2$ 이하이므로, 이런 구조에서는 path와 cycle만이 존재합니다. 이 중에서 우리는 $v_{1} \\lt v_{2} \\lt \\cdots \u003c v_{q}$를 차례로 잇는 simple increasing path들만을 먼저 생각합시다.\nSimple increasing path들로 분할하고 나면 문제가 한층 쉬워집니다. 이제 각 정점의 차수는 1 이하가 되고, 앞서 다룬 케이스에 따라 엇갈리게 Path들을 놓으면 됩니다. 다만 이 경우에, $l’ \\le l \\le r \\le r’$을 만족하는 두 chain $[l’, r’]$, $[l, r]$에 대해 $[l, r]$을 그냥 버리면 안됩니다.\nSimple path가 아닌 path나 cycle의 경우, 사실상 simple path와 동등하게 생각할 수 있습니다. 상세한 증명은 원 editorial https://dmoj.ca/problem/dmopc21c7p5/editorial 을 참고하시기 바랍니다.\nKTH challenge 2015 H “The Addition Game” 길이 $n$의 수열 $a$가 주어지면, $\\pi + \\sigma = a \\pmod{n}$을 만족하는 $\\pi, \\sigma$를 찾아야 합니다. 이야기하기 쉽게, $a - \\pi$가 순열이 되는 $\\pi$를 찾는 문제로 생각합시다. 당연히 $a_{1} + \\cdots + a_{n} = 0 \\pmod{n}$이어야 해가 존재하고, 놀랍게도 이 조건만 만족하면 해가 존재합니다. 이 문제에는 잘 통하는 휴리스틱과 어려운 정해가 있습니다.\nHeuristic $a - \\pi$가 순열이 아니라면, $a - \\pi$에 두 번 이상 등장하는 수 $k$와 한 번도 등장하지 않는 수 $l$이 존재합니다. 이 때 $k = (a - \\pi){i}$를 만족하는 $i$와, $a{i} - \\pi_{j} = l$을 만족하는 $j$를 잡고 $\\pi_{i}, \\pi_{j}$를 swap하면 $l$의 개수가 하나 늘어나고, $k$의 개수는 감소하거나 유지됩니다. 이 방법의 단점은 $m = a_{j} - \\pi_{j}$의 개수가 $0$개로 줄어들거나 $p = a_{j} - \\pi_{i}$의 개수가 늘어날 수 있다는 점인데, 적절히 구현하면 놀랍게도 만점을 받을 수 있습니다.\nDeterministic $a = \\mathbf{0}$이라고 생각합시다. 이 경우에는 $\\pi_{i} = i, \\sigma_{i} = -i$로 두면 됩니다. 이제 이 상태에서 $\\pi$에 적당한 swap을 통해 $a^{1} = (a_{1}, -a_{1}, 0, \\cdots, 0) = \\pi^{1} + \\sigma^{1}$을 만들고, 다시 $\\pi^{1}$을 적당히 재배열해서 $a^{2} = (a_{1}, a_{2}, -a_{1}-a_{2}, 0, \\cdots, 0) = \\pi^{2} + \\sigma^{2}$를 만드는 방식을 $n-1$번 반복할 수 있습니다. 각 단계에서 $\\sigma^{k} = a^{k} - \\pi^{k}$ 역시 순열이어야 합니다. 이렇게 과정을 분해하는 까닭은 값이 2개만 틀려 있을 때만 문제를 해결해도 충분하다는 것을 이야기하기 위함입니다.\n보다 일반적으로, $\\pi(i_{1}) + \\sigma(i_{1}) \\neq a(i_{1})$, $\\pi(i_{2}) + \\sigma(i_{2}) \\neq a(i_{2})$라고 하고, $i \\neq i_{1}, i_{2}$에 대해 $\\pi(i) + \\sigma(i) = a(i)$라고 합시다. 따라서 $\\pi(i_{1}) + \\pi(i_{2}) + \\sigma(i_{1}) + \\sigma(i_{2}) = a(i_{1}) + a(i_{2})$가 성립합니다.\n편의상 어떤 배열 $b$의 값 $b(i_{1})$ (혹은 $b(i_{2})$)와 다른 위치 $j \\neq i_{1}, i_{2}$의 값 $b(j)$를 swap하는 것을 $b(i_{1})$을 “넣고” $b(j)$를 “빼낸다\"라고 표현하겠습니다.\n만약 $\\pi(i_{1}) + \\sigma(i_{\\ast}) = a(i_{1})$이 성립한다면 끝입니다. 그렇지 않다면 $\\pi(j_{1}) + \\sigma(i_{1}) = a(i_{1})$을 만족하는 $j_{1} \\neq i_{1}, i_{2}$이 유일하게 존재합니다. 따라서 $a(i_{1})$과 $\\sigma(i_{1})$을 넣고, $a(j_{1})$과 $\\sigma(j_{1})$을 빼냅시다. 이는 $\\pi(i_{1})$과 $\\pi(j_{1})$을 swap하는 것과 동치인 연산입니다.\n여전히 빠져나온 $\\pi$의 두 원소를 적당히 swap해서 조건을 만족하는 수열을 만들 수 없다면 이번에는 $a(j_{1}), \\sigma(i_{2})$를 넣어줍시다. $a(j_{1}), \\sigma(j_{1})$을 넣으려고 시도하면 결국 원래 넣었던 $a(i_{1})$이 빠져나올테니까요. 빠져나온 수를 $a(j_{2}), \\sigma(j_{2})$라고 둡시다. $a(i_{2})$는 넣지 않고 남겨둘 겁니다.\n결국 $k \\ge 3$번째 step에서는 $a(j_{k-1}), \\sigma(j_{k-2})$을 넣고, $a(j_{k}), \\sigma(j_{k})$를 빼내는 과정을 반복하게 됩니다. 이 과정이 무한히 반복될 수 없음을 보입시다. $\\pi(j_{1}), \\cdots, \\pi(j_{t})$는 모두 distinct하지만 $\\pi(j_{s}) = \\pi(j_{t+1})$을 만족하는 $s \\le t$가 존재할 것입니다.\n이 때 $t+1$번째 step에서 빠져나오는 인덱스가 바로 $j_{s}$가 되는데, $j_{s}$가 빠져나올 당시 대신 넣어준 수는 바로 $a(j_{s-1}), \\sigma(j_{s-2})$입니다. 따라서 관계식\n$$ \\pi(i_{1}) + \\pi(i_{2}) + \\sigma(j_{t}) + \\sigma(j_{s-2}) = a(i_{2}) + a(j_{s-1}) $$ 이 성립하게 됩니다. 한편 $s$번째 step에서\n$$ \\pi(i_{1}) + \\pi(i_{2}) + \\sigma(j_{s-1}) + \\sigma(j_{s-2}) = a(i_{2}) + a(j_{s-1}) $$\n이 성립하므로, $\\sigma(j_{s-1}) = \\sigma(j_{t})$가 됩니다. 이 때 $\\pi(j_{1}), \\cdots, \\pi(j_{t})$가 모두 distinct하고 $\\pi, \\sigma$는 모두 순열이므로 모순이 발생합니다. 따라서 step은 최대 $n-2$번 지속될 수 있고, 총 $O(n^2)$ 시간에 문제를 해결할 수 있습니다.\nCERC 2017 E “Embedding Enumeration” $D_{x}$를 $x$가 왼쪽 위 모서리에 위치할 때 $x$의 서브트리를 배치하는 방법의 수라고 합시다. 당연히 $x$의 차수는 $2$ 이하여야 하고, 모든 정점의 차수는 $3$ 이하여야 합니다.\n$x$가 리프인 경우는 $D_{x} = 1$이므로, $x$가 자식이 $1$개 또는 $2$개인 경우만 고려하면 됩니다.\n자식이 2개인 경우 $x$의 두 자식을 $h, v$라고 하고, 일반성을 잃지 않고 $h$가 오른쪽으로, $v$가 아래로 뻗는다고 합시다. $v$는 자식이 최대 1개여야 합니다. 자식이 있다면 그걸 $v_{0}$라고 두면, $h$와 $v_{0}$가 격자의 가장 왼쪽 칸을 채우게 됩니다. 이 때 아래 케이스를 이용해 처리해줍니다.\nImportant Subcase: “Two Heads Case” 어떤 두 정점 $a, b$가 격자의 왼쪽 칸을 메우고 있을 때, 두 정점의 서브트리를 배치하는 경우의 수를 생각해 봅시다. 편의상 $a$의 서브트리 크기 $s_{a}$가 $b$의 크기 $s_{b}$보다 작다고 합시다.\n그렇다면 $a$는 길이 $s_{a}$의 직선이어야만 합니다. 또한 $b$도 길이 $s_{a}$의 직선을 직속 서브트리로 가져야 합니다. 이 때 $b$의 $s_{a}$번째 자식을 $b’$이라고 두면, $D_{b’}$이 답이 됩니다.\n자식이 1개인 경우 만약 $x$의 서브트리가 직선이라면, 고려해줄 특이 케이스가 있습니다. 거꾸로 된 ㄷ자 모양으로 격자를 채우는 경우인데, DP의 특성상 $x$의 서브트리 크기가 홀수일 때만 $D_{x}$에 1을 더해주는 걸로 충분합니다.\n이외의 경우, $x$의 서브트리 중에서 자식이 둘인 깊이가 가장 작은 정점 $h$가 존재합니다. 역시 $h$에서 케이스 처리를 해주면 됩니다.\n시작부터 방향을 아래쪽으로 틀어 채우는 경우, $x$와 $h$의 깊이 차이가 2 이상이어야 합니다. $x$의 grandson을 $y$라고 두면, $D_{y}$를 더해줍니다. 이는 $x$에서 $h$의 grandparent 사이에 방향을 전환하는 모든 경우를 아우르고 있습니다.\n$h$의 부모 정점에서 방향을 아래쪽으로 트는 경우, $h$의 두 자식 $u, v$ 중 하나는 왼쪽의 빈 공간으로 보내야 합니다. 따라서 둘 중 하나는 크기가 작은 직선이어야 합니다. $u$를 보낸다고 하면 $D_{v}$가 답이 될 것입니다.\n$h$까지 방향을 틀지 않는 경우, $h$의 두 자식 $u, v$ 중 하나를 아래로 보냅니다. $v$를 보낸다고 할 때, $v$는 자식이 둘이어도 됩니다. 다만 두 자식 중 하나는 왼쪽의 빈 공간을 채워야 하므로, 크기가 작은 직선이어야 합니다. 왼쪽으로 보내지 않는 자식을 $v_{r}$이라고 할 때, $u, v_{r}$을 이용해 Two Head Case를 처리해 주면 됩니다.\n디테일을 다소 생략하였으나, 전체 케이스를 $O(N)$에 구현할 수 있습니다.\nJAG Summer Camp 2013 Day 4 J “Rotation Game” 우선 wild-card 문자 *가 없는 경우를 처리해봅시다. 만약 시작 문자열에 o가 있는 칸에 도착 문자열에는 .가 있다면 그 칸에 +, 반대로 시작 문자열에는 .가 있고 도착 문자열에는 o가 있다면 -를 적어줍시다. +와 -의 개수는 같다고 가정해도 됩니다.\n문제에서 가능한 변환들이 주는 의미는 결국 하나의 +를 한 열 움직이는 데 1번의 회전이 필요하다는 것입니다. 또, 한 번의 회전이면 + 한개를 다른 +들에 영향을 미치지 않고 이동시킬 수 있다는 의미이기도 합니다.\n이렇게 되면, 모든 +와 모든 -를 가장 거리가 가까운 것끼리 매칭시켜주고, 매칭된 +, - 사이 거리의 합이 최적해인 것처럼 보입니다. 이는 stack을 이용해 잉여 +, 잉여 -를 관리하면 $O(N)$에 매칭해줄 수 있습니다.\n하지만 몇 가지 예외 케이스가 있는데, 바로 +, -가 같은 열에 있는 경우, 또 아래와 같이 +-와 -+이 맞물려 있는 경우입니다.\n..+-.. ..-+.. 첫 번째로 +-가 한 열에 맞물려 있는 경우, 단순히 같은 열의 +, -를 비용 0으로 이어주면 안됩니다. 하지만 이 열보다 왼쪽에 잉여 +가 존재할 경우 이 열의 -를 잉여 +에 매칭해 주고, 이 열의 +를 잉여 +로 남기면 됩니다. 잉여 -가 존재하는 경우도 마찬가지입니다. 따라서 이 열 왼쪽에 잉여 +, -가 존재하지 않는 경우에만 비용에 1을 더해줍니다.\n두 번째로 +-, -+이 맞물려 놓이는 경우, 회전 한 번으로 두 열을 모두 돌릴 수 있습니다. 이 역시도 왼쪽에 잉여 +, 잉여 -가 없는 경우에만 성립합니다. 따라서 +-, -+, … 이 교대로 $k$번 반복될 경우, 비용에 $\\lceil k / 2 \\rceil$을 더해주면 됩니다.\nwild-card *가 있는 경우에도 이 풀이를 자연스럽게 확장할 수 있습니다. $D(i, j, u, d)$를 $i$번째 열까지 봤고, 잉여 +가 $j$개이며, ($j \u003c 0$인 경우 잉여 -가 있는 것으로 봅니다) 직전 두 열이 각각 $u, d$인 경우 비용의 최솟값으로 두고 DP를 해결하면 됩니다.\n","wordCount":"1929","inLanguage":"en","datePublished":"2023-12-26T17:02:49+09:00","dateModified":"2023-12-26T17:02:49+09:00","author":{"@type":"Person","name":"TAMREF"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tamref.github.io/posts/migrated/ps_20220716/"},"publisher":{"@type":"Organization","name":"TAMREF's blog","logo":{"@type":"ImageObject","url":"https://tamref.github.io/assets/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tamref.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tamref.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tamref.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tamref.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://tamref.com title="My tistory blog"><span>My tistory blog</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tamref.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tamref.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Ps_20220716</h1><div class=post-meta><span title='2023-12-26 17:02:49 +0900 KST'>December 26, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1929 words&nbsp;·&nbsp;TAMREF&nbsp;|&nbsp;<a href=https://github.com/TAMREF/tamref.github.io/posts/migrated/ps_20220716.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>교육용으로 사용한 10문제의 풀이입니다. 용어가 원본 문제와 다를 수 있습니다.</p><h2 id=bapc-2021-f-fair-play>BAPC 2021 F. &ldquo;Fair Play&rdquo;<a hidden class=anchor aria-hidden=true href=#bapc-2021-f-fair-play>#</a></h2><p>$n$이 홀수인 경우는 당연히 불가능하고, 짝수인 경우 $(b, p)$를 <code>std::pair</code> 와 같은 방식으로 정렬한 것을 $(b_{1}, p_{1}), \cdots, (b_{n}, p_{n})$이라고 둡시다. 이 때 유일하게 가능한 매칭 방법은 $(b_{1}, p_{1})$을 $(b_{n}, p_{n})$과, $(b_{2}, p_{2})$를 $(b_{n-1}, p_{n-1})$과 &mldr; 매칭해주는 것입니다. 이렇게 해서 벡터합이 모두 균일하다면 <code>possible</code>, 그렇지 않다면 <code>impossible</code> 입니다.</p><h2 id=bapc-2021-i-implementation-irregularities>BAPC 2021 I &ldquo;Implementation Irregularities&rdquo;<a hidden class=anchor aria-hidden=true href=#bapc-2021-i-implementation-irregularities>#</a></h2><p>$s_{i}$가 증가하는 순서대로 원소들을 배열하고, $s_{i} = -1$인 원소들을 제외합시다. 이 때 답은 $\max_{i} \lceil \frac{t_{1} + \cdots + t_{i}}{s_{i}} \rceil$가 됩니다.</p><h2 id=20212022-coci-contest-2-b-kutije>2021/2022 COCI Contest #2 B &ldquo;Kutije&rdquo;<a hidden class=anchor aria-hidden=true href=#20212022-coci-contest-2-b-kutije>#</a></h2><p>한 순열 $p(1), \cdots, p(n)$에 대해 $i$번 정점과 $p(i)$번 정점을 간선으로 이어주면, 이는 사이클 몇 개로 분할되는 그래프를 이룹니다. 결국 주어지는 쿼리는 $a, b$가 같은 연결컴포넌트에 있는지를 물어보는 것이고, 사전에 DFS, union-find를 통해 컴포넌트를 구해두면 쿼리당 $O(1)$에 해결할 수 있습니다.</p><h2 id=cerc-2015-k-kernel-knights>CERC 2015 K &ldquo;Kernel Knights&rdquo;<a hidden class=anchor aria-hidden=true href=#cerc-2015-k-kernel-knights>#</a></h2><p>Indegree가 0인 정점 $a$는 무조건 선택해야 하고, 따라서 $f_{a}$는 무조건 배제해야 합니다. 이제 전체 그래프에서 $a, f_{a}$를 제외한 뒤 같은 과정을 반복하면 최종적으로 아무 정점도 남지 않거나, cycle이 남게 됩니다. 그래프가 이분그래프이기 때문에 이는 짝수 길이 cycle이 되고, 이 중에서는 범위($[1, N]$ 혹은 $[N+1, 2N]$)가 같은 점들만 골라주면 됩니다.</p><h2 id=2020-jakarta-regional-j-token-distance>2020 Jakarta Regional J &ldquo;Token Distance&rdquo;<a hidden class=anchor aria-hidden=true href=#2020-jakarta-regional-j-token-distance>#</a></h2><p>좀 더 쉬운 버전인, 어떤 구간 $[s, e]$를 정렬했을 때 $\set{x, x + 1, \cdots, x + e - s}$가 될 필요충분조건을 생각해 봅시다.</p><ul><li>구간 $[s, e]$의 최댓값 - 최솟값이 정확히 $e - s$이다.</li><li>구간 $[s, e]$에 중복 원소가 존재하지 않는다.</li></ul><p>하지만 일반적으로 $\set{x, x + g, \cdots, x + g (e - s)}$를 이룰 조건은 위 두개만으론 불충분합니다. 이 때 다음이 성립합니다.</p><p><strong>Proposition.</strong> 구간 $[s, e]$의 수를 $A_{s}, \cdots, A_{e}$라고 하자. 다음 세 조건을 동시에 만족하는 것과, $\set{A_{s}, \cdots, A_{e}} = \set{x, x + g, \cdots, x + g(e-s)}$가 성립하는 것은 동치이다.</p><ul><li>$\max(A_{s}, \cdots, A_{e}) - \min(A_{s}, \cdots, A_{e}) = g(e-s)$.</li><li>$A_{s}, \cdots, A_{e}$중 중복되는 값이 존재하지 않는다.</li><li>$\gcd(A_{s} - A_{s+1}, A_{s+1} - A_{s+2}, \cdots, A_{e-1} - A_{e}) = g$.</li></ul><p>$\set{A_{s}, \cdots, A_{e}} = \set{x, \cdots, x + g(e-s)}$가 성립하는 경우 $\gcd$ 조건을 만족하게 됩니다. $\gcd$는 $g$의 배수가 될 것이고, 정확히 $g$가 아니면 $A_{s} \pm g$가 등장할 수 없기 때문입니다. 또한 $\gcd$ 조건을 만족하는 수열은 모두 $\set{x, \cdots, x + g(e-s)}$의 재배열뿐입니다.</p><p>위 세가지 조건은 모두 Segment Tree 등을 이용해 판별할 수 있고, 시간복잡도는 $O(N \log N)$이 됩니다.</p><h2 id=20212022-coci-contest-2-e-osumnjičeni>2021/2022 COCI Contest #2 E &ldquo;Osumnjičeni&rdquo;<a hidden class=anchor aria-hidden=true href=#20212022-coci-contest-2-e-osumnjičeni>#</a></h2><p>주어진 $i$에 대해서, 구간 $[L_{i}, R_{i}], \cdots, [L_{j}, R_{j}]$가 서로소가 되는 $j$의 최댓값을 미리 구해두고, 이를 $p(i)$라고 합시다. $p(i)$는 two-pointer로 $O(N\log N)$ 시간에 구할 수 있습니다.</p><p>$p^{0}(i) = i, p^{k}(i) = p(p^{k-1}(i))$로 정의하면, $[s, e]$ 형태로 쿼리가 들어올 경우 답은 $p^{k}(s) \ge e$를 만족하는 $k$의 최솟값이 됩니다. 이는 $p^{k}(i)$를 sparse table 등으로 구해두면 $O(N \log N + Q \log N)$ 시간에 해결할 수 있습니다.</p><h2 id=dmopc-21-contest-7-problem-5-kings-commands>DMOPC &lsquo;21 Contest #7 Problem 5, &ldquo;King&rsquo;s Commands&rdquo;<a hidden class=anchor aria-hidden=true href=#dmopc-21-contest-7-problem-5-kings-commands>#</a></h2><p>보다 간단한 경우로 $\deg(a, 0) + \deg(a, 1) \le 1$인 경우를 생각해 봅시다. 연결 컴포넌트의 개수는 Degree가 0인 정점 (lone vertex)의 수와 선분들의 연결 컴포넌트 개수의 합으로 나타낼 수 있습니다.</p><p>만약 $\deg(a, 0) + \deg(a, 1) \le 1$이라면, lone vertex의 수는 상수로 유지되는 것을 알 수 있습니다. 따라서 선분들의 컴포넌트 수를 최소화하는 데만 집중하면 됩니다.</p><p>$(l, 0), (r, 1)$을 잇는 선분을 $[l, r]$로 표기합시다. (편의상 $l \le r$을 가정합니다) 만약 $l&rsquo; \le l \le r \le r&rsquo;$을 만족하는 $[l&rsquo;, r&rsquo;]$이 존재할 경우 $[l, r]$은 어떻게 놓아도 $[l&rsquo;, r&rsquo;]$과 이어지므로 신경쓰지 않아도 됩니다. 따라서 모든 선분들을 $l$ 순으로 정렬한 것을 $[l_{1}, r_{1}], \cdots, [l_{n}, r_{n}]$이라고 두면 $r_{1} &lt; r_{2} &lt; \cdots &lt; r_{n}$을 가정할 수 있습니다. 마찬가지로 $l_{1} &lt; l_{2} &lt; \cdots &lt; l_{n}$ 또한 가정할 수 있습니다.</p><p>만약 $r_{k} \lt l_{k+1}$이라면 어떻게 하더라도 두 선분 $[l_{k}, r_{k}]$와 $[l_{k+1}, r_{k+1}]$을 이을 수 없고, $r_{k} > l_{k+1}$이라면 둘을 엇갈리게 놓아서 연결할 수 있습니다.</p><p>이제 본 문제를 해결해 봅시다. 차수가 2인 경우에는 간선을 어떻게 배치하느냐에 따라 lone vertex의 수가 달라질 수 있습니다. 이 때 간선들을 bottom vertex에 따라 정렬하고, 연속한 간선들을 group $G_{1}, G_{2}, \cdots, G_{k}$로 최대한 쪼갭시다. 이 때 모든 $1 \le i \lt k$에 대해 $G_{1}, \cdots, G_{i}$의 top vertex 중 가장 오른쪽에 있는 것이 $G_{i+1}, \cdots, G_{k}$의 top vertex 중 가장 왼쪽에 있는 것보다 작거나 같아야 합니다. 이 때 각 group의 간선들은 차수 2인 정점 없이, 모두 연결되도록 할 수 있습니다. group $G_{i}$까지 모두 연결되도록 했을 때, 어떤 정점 $x$가 존재하여 $G_{i}$의 간선과 $G_{i+1}$의 간선에 모두 연결된다고 합시다. 이 경우 $G_{1}, \cdots, G_{i}$를 모두 뒤집어주면 컴포넌트의 개수는 최대 1 감소하는 반면, lone vertex의 수는 확실히 1 감소하여 답이 줄어들지 않습니다.</p><p>즉, 답이 $k$인 간선 배치가 주어지면 답이 $k$ 이상이고 차수 2인 정점이 없는 배치를 만들 수 있으므로, 우리는 <strong>차수 2인 정점이 없는 배치 중 컴포넌트 갯수가 가장 적은 배치</strong>를 찾을 것입니다.</p><p>어떤 점 $(a, 0), (a, 1)$에 연결된 간선이 2개라면, 두 간선이 연결된 점은 달라야 합니다. 모든 정점 $(a, \ast)$의 차수가 $2$ 이하이므로, 이런 구조에서는 path와 cycle만이 존재합니다. 이 중에서 우리는 $v_{1} \lt v_{2} \lt \cdots &lt; v_{q}$를 차례로 잇는 simple increasing path들만을 먼저 생각합시다.</p><p>Simple increasing path들로 분할하고 나면 문제가 한층 쉬워집니다. 이제 각 정점의 차수는 1 이하가 되고, 앞서 다룬 케이스에 따라 엇갈리게 Path들을 놓으면 됩니다. 다만 이 경우에, $l&rsquo; \le l \le r \le r&rsquo;$을 만족하는 두 chain $[l&rsquo;, r&rsquo;]$, $[l, r]$에 대해 $[l, r]$을 그냥 버리면 안됩니다.</p><p>Simple path가 아닌 path나 cycle의 경우, 사실상 simple path와 동등하게 생각할 수 있습니다. 상세한 증명은 원 editorial <a href=https://dmoj.ca/problem/dmopc21c7p5/editorial>https://dmoj.ca/problem/dmopc21c7p5/editorial</a> 을 참고하시기 바랍니다.</p><h2 id=kth-challenge-2015-h-the-addition-game>KTH challenge 2015 H &ldquo;The Addition Game&rdquo;<a hidden class=anchor aria-hidden=true href=#kth-challenge-2015-h-the-addition-game>#</a></h2><p>길이 $n$의 수열 $a$가 주어지면, $\pi + \sigma = a \pmod{n}$을 만족하는 $\pi, \sigma$를 찾아야 합니다. 이야기하기 쉽게, $a - \pi$가 순열이 되는 $\pi$를 찾는 문제로 생각합시다. 당연히 $a_{1} + \cdots + a_{n} = 0 \pmod{n}$이어야 해가 존재하고, 놀랍게도 이 조건만 만족하면 해가 존재합니다. 이 문제에는 잘 통하는 휴리스틱과 어려운 정해가 있습니다.</p><h3 id=heuristic>Heuristic<a hidden class=anchor aria-hidden=true href=#heuristic>#</a></h3><p>$a - \pi$가 순열이 아니라면, $a - \pi$에 두 번 이상 등장하는 수 $k$와 한 번도 등장하지 않는 수 $l$이 존재합니다. 이 때 $k = (a - \pi)<em>{i}$를 만족하는 $i$와, $a</em>{i} - \pi_{j} = l$을 만족하는 $j$를 잡고 $\pi_{i}, \pi_{j}$를 swap하면 $l$의 개수가 하나 늘어나고, $k$의 개수는 감소하거나 유지됩니다. 이 방법의 단점은 $m = a_{j} - \pi_{j}$의 개수가 $0$개로 줄어들거나 $p = a_{j} - \pi_{i}$의 개수가 늘어날 수 있다는 점인데, 적절히 구현하면 놀랍게도 만점을 받을 수 있습니다.</p><h3 id=deterministic>Deterministic<a hidden class=anchor aria-hidden=true href=#deterministic>#</a></h3><p>$a = \mathbf{0}$이라고 생각합시다. 이 경우에는 $\pi_{i} = i, \sigma_{i} = -i$로 두면 됩니다. 이제 이 상태에서 $\pi$에 적당한 swap을 통해 $a^{1} = (a_{1}, -a_{1}, 0, \cdots, 0) = \pi^{1} + \sigma^{1}$을 만들고, 다시 $\pi^{1}$을 적당히 재배열해서 $a^{2} = (a_{1}, a_{2}, -a_{1}-a_{2}, 0, \cdots, 0) = \pi^{2} + \sigma^{2}$를 만드는 방식을 $n-1$번 반복할 수 있습니다. 각 단계에서 $\sigma^{k} = a^{k} - \pi^{k}$ 역시 순열이어야 합니다. 이렇게 과정을 분해하는 까닭은 값이 2개만 틀려 있을 때만 문제를 해결해도 충분하다는 것을 이야기하기 위함입니다.</p><p>보다 일반적으로, $\pi(i_{1}) + \sigma(i_{1}) \neq a(i_{1})$, $\pi(i_{2}) + \sigma(i_{2}) \neq a(i_{2})$라고 하고, $i \neq i_{1}, i_{2}$에 대해 $\pi(i) + \sigma(i) = a(i)$라고 합시다. 따라서 $\pi(i_{1}) + \pi(i_{2}) + \sigma(i_{1}) + \sigma(i_{2}) = a(i_{1}) + a(i_{2})$가 성립합니다.</p><p>편의상 어떤 배열 $b$의 값 $b(i_{1})$ (혹은 $b(i_{2})$)와 다른 위치 $j \neq i_{1}, i_{2}$의 값 $b(j)$를 swap하는 것을 $b(i_{1})$을 &ldquo;넣고&rdquo; $b(j)$를 &ldquo;빼낸다"라고 표현하겠습니다.</p><p>만약 $\pi(i_{1}) + \sigma(i_{\ast}) = a(i_{1})$이 성립한다면 끝입니다. 그렇지 않다면 $\pi(j_{1}) + \sigma(i_{1}) = a(i_{1})$을 만족하는 $j_{1} \neq i_{1}, i_{2}$이 유일하게 존재합니다. 따라서 $a(i_{1})$과 $\sigma(i_{1})$을 넣고, $a(j_{1})$과 $\sigma(j_{1})$을 빼냅시다. 이는 $\pi(i_{1})$과 $\pi(j_{1})$을 swap하는 것과 동치인 연산입니다.</p><p>여전히 빠져나온 $\pi$의 두 원소를 적당히 swap해서 조건을 만족하는 수열을 만들 수 없다면 이번에는 $a(j_{1}), \sigma(i_{2})$를 넣어줍시다. $a(j_{1}), \sigma(j_{1})$을 넣으려고 시도하면 결국 원래 넣었던 $a(i_{1})$이 빠져나올테니까요. 빠져나온 수를 $a(j_{2}), \sigma(j_{2})$라고 둡시다. $a(i_{2})$는 넣지 않고 남겨둘 겁니다.</p><p>결국 $k \ge 3$번째 step에서는 $a(j_{k-1}), \sigma(j_{k-2})$을 넣고, $a(j_{k}), \sigma(j_{k})$를 빼내는 과정을 반복하게 됩니다. 이 과정이 무한히 반복될 수 없음을 보입시다. $\pi(j_{1}), \cdots, \pi(j_{t})$는 모두 distinct하지만 $\pi(j_{s}) = \pi(j_{t+1})$을 만족하는 $s \le t$가 존재할 것입니다.</p><p>이 때 $t+1$번째 step에서 빠져나오는 인덱스가 바로 $j_{s}$가 되는데, $j_{s}$가 빠져나올 당시 대신 넣어준 수는 바로 $a(j_{s-1}), \sigma(j_{s-2})$입니다. 따라서 관계식</p><p>$$
\pi(i_{1}) + \pi(i_{2}) + \sigma(j_{t}) + \sigma(j_{s-2}) = a(i_{2}) + a(j_{s-1})
$$
이 성립하게 됩니다. 한편 $s$번째 step에서</p><p>$$
\pi(i_{1}) + \pi(i_{2}) + \sigma(j_{s-1}) + \sigma(j_{s-2}) = a(i_{2}) + a(j_{s-1})
$$</p><p>이 성립하므로, $\sigma(j_{s-1}) = \sigma(j_{t})$가 됩니다. 이 때 $\pi(j_{1}), \cdots, \pi(j_{t})$가 모두 distinct하고 $\pi, \sigma$는 모두 순열이므로 모순이 발생합니다. 따라서 step은 최대 $n-2$번 지속될 수 있고, 총 $O(n^2)$ 시간에 문제를 해결할 수 있습니다.</p><h2 id=cerc-2017-e-embedding-enumeration>CERC 2017 E &ldquo;Embedding Enumeration&rdquo;<a hidden class=anchor aria-hidden=true href=#cerc-2017-e-embedding-enumeration>#</a></h2><p>$D_{x}$를 $x$가 왼쪽 위 모서리에 위치할 때 $x$의 서브트리를 배치하는 방법의 수라고 합시다. 당연히 $x$의 차수는 $2$ 이하여야 하고, 모든 정점의 차수는 $3$ 이하여야 합니다.</p><p>$x$가 리프인 경우는 $D_{x} = 1$이므로, $x$가 자식이 $1$개 또는 $2$개인 경우만 고려하면 됩니다.</p><h3 id=자식이-2개인-경우>자식이 2개인 경우<a hidden class=anchor aria-hidden=true href=#자식이-2개인-경우>#</a></h3><p>$x$의 두 자식을 $h, v$라고 하고, 일반성을 잃지 않고 $h$가 오른쪽으로, $v$가 아래로 뻗는다고 합시다. $v$는 자식이 최대 1개여야 합니다. 자식이 있다면 그걸 $v_{0}$라고 두면, $h$와 $v_{0}$가 격자의 가장 왼쪽 칸을 채우게 됩니다. 이 때 아래 케이스를 이용해 처리해줍니다.</p><h3 id=important-subcase-two-heads-case>Important Subcase: &ldquo;Two Heads Case&rdquo;<a hidden class=anchor aria-hidden=true href=#important-subcase-two-heads-case>#</a></h3><p>어떤 두 정점 $a, b$가 격자의 왼쪽 칸을 메우고 있을 때, 두 정점의 서브트리를 배치하는 경우의 수를 생각해 봅시다. 편의상 $a$의 서브트리 크기 $s_{a}$가 $b$의 크기 $s_{b}$보다 작다고 합시다.</p><p>그렇다면 $a$는 길이 $s_{a}$의 직선이어야만 합니다. 또한 $b$도 길이 $s_{a}$의 직선을 직속 서브트리로 가져야 합니다. 이 때 $b$의 $s_{a}$번째 자식을 $b&rsquo;$이라고 두면, $D_{b&rsquo;}$이 답이 됩니다.</p><h3 id=자식이-1개인-경우>자식이 1개인 경우<a hidden class=anchor aria-hidden=true href=#자식이-1개인-경우>#</a></h3><p>만약 $x$의 서브트리가 직선이라면, 고려해줄 특이 케이스가 있습니다. 거꾸로 된 ㄷ자 모양으로 격자를 채우는 경우인데, DP의 특성상 $x$의 서브트리 크기가 홀수일 때만 $D_{x}$에 1을 더해주는 걸로 충분합니다.</p><p>이외의 경우, $x$의 서브트리 중에서 자식이 둘인 깊이가 가장 작은 정점 $h$가 존재합니다. 역시 $h$에서 케이스 처리를 해주면 됩니다.</p><p>시작부터 방향을 아래쪽으로 틀어 채우는 경우, $x$와 $h$의 깊이 차이가 2 이상이어야 합니다. $x$의 grandson을 $y$라고 두면, $D_{y}$를 더해줍니다. 이는 $x$에서 $h$의 grandparent 사이에 방향을 전환하는 모든 경우를 아우르고 있습니다.</p><p>$h$의 부모 정점에서 방향을 아래쪽으로 트는 경우, $h$의 두 자식 $u, v$ 중 하나는 왼쪽의 빈 공간으로 보내야 합니다. 따라서 둘 중 하나는 크기가 작은 직선이어야 합니다. $u$를 보낸다고 하면 $D_{v}$가 답이 될 것입니다.</p><p>$h$까지 방향을 틀지 않는 경우, $h$의 두 자식 $u, v$ 중 하나를 아래로 보냅니다. $v$를 보낸다고 할 때, $v$는 자식이 둘이어도 됩니다. 다만 두 자식 중 하나는 왼쪽의 빈 공간을 채워야 하므로, 크기가 작은 직선이어야 합니다. 왼쪽으로 보내지 않는 자식을 $v_{r}$이라고 할 때, $u, v_{r}$을 이용해 Two Head Case를 처리해 주면 됩니다.</p><p>디테일을 다소 생략하였으나, 전체 케이스를 $O(N)$에 구현할 수 있습니다.</p><h2 id=jag-summer-camp-2013-day-4-j-rotation-game>JAG Summer Camp 2013 Day 4 J &ldquo;Rotation Game&rdquo;<a hidden class=anchor aria-hidden=true href=#jag-summer-camp-2013-day-4-j-rotation-game>#</a></h2><p>우선 wild-card 문자 <code>*</code>가 없는 경우를 처리해봅시다. 만약 시작 문자열에 <code>o</code>가 있는 칸에 도착 문자열에는 <code>.</code>가 있다면 그 칸에 <code>+</code>, 반대로 시작 문자열에는 <code>.</code>가 있고 도착 문자열에는 <code>o</code>가 있다면 <code>-</code>를 적어줍시다. <code>+</code>와 <code>-</code>의 개수는 같다고 가정해도 됩니다.</p><p>문제에서 가능한 변환들이 주는 의미는 결국 하나의 <code>+</code>를 한 열 움직이는 데 1번의 회전이 필요하다는 것입니다. 또, 한 번의 회전이면 <code>+</code> 한개를 다른 <code>+</code>들에 영향을 미치지 않고 이동시킬 수 있다는 의미이기도 합니다.</p><p>이렇게 되면, 모든 <code>+</code>와 모든 <code>-</code>를 가장 거리가 가까운 것끼리 매칭시켜주고, 매칭된 <code>+</code>, <code>-</code> 사이 거리의 합이 최적해인 것처럼 보입니다. 이는 stack을 이용해 잉여 <code>+</code>, 잉여 <code>-</code>를 관리하면 $O(N)$에 매칭해줄 수 있습니다.</p><p>하지만 몇 가지 예외 케이스가 있는데, 바로 <code>+</code>, <code>-</code>가 같은 열에 있는 경우, 또 아래와 같이 <code>+-</code>와 <code>-+</code>이 맞물려 있는 경우입니다.</p><pre tabindex=0><code>..+-..
..-+..
</code></pre><p>첫 번째로 <code>+-</code>가 한 열에 맞물려 있는 경우, 단순히 같은 열의 <code>+</code>, <code>-</code>를 비용 0으로 이어주면 안됩니다. 하지만 이 열보다 왼쪽에 잉여 <code>+</code>가 존재할 경우 이 열의 <code>-</code>를 잉여 <code>+</code>에 매칭해 주고, 이 열의 <code>+</code>를 잉여 <code>+</code>로 남기면 됩니다. 잉여 <code>-</code>가 존재하는 경우도 마찬가지입니다. 따라서 이 열 왼쪽에 잉여 <code>+</code>, <code>-</code>가 존재하지 않는 경우에만 비용에 1을 더해줍니다.</p><p>두 번째로 <code>+-</code>, <code>-+</code>이 맞물려 놓이는 경우, 회전 한 번으로 두 열을 모두 돌릴 수 있습니다. 이 역시도 왼쪽에 잉여 <code>+</code>, 잉여 <code>-</code>가 없는 경우에만 성립합니다. 따라서 <code>+-</code>, <code>-+</code>, &mldr; 이 교대로 $k$번 반복될 경우, 비용에 $\lceil k / 2 \rceil$을 더해주면 됩니다.</p><p>wild-card <code>*</code>가 있는 경우에도 이 풀이를 자연스럽게 확장할 수 있습니다. $D(i, j, u, d)$를 $i$번째 열까지 봤고, 잉여 <code>+</code>가 $j$개이며, ($j &lt; 0$인 경우 잉여 <code>-</code>가 있는 것으로 봅니다) 직전 두 열이 각각 $u, d$인 경우 비용의 최솟값으로 두고 DP를 해결하면 됩니다.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://tamref.github.io/posts/migrated/ps_20200811/><span class=title>« Prev</span><br><span>Ps_20200811</span>
</a><a class=next href=https://tamref.github.io/posts/migrated/grundy-number-1/><span class=title>Next »</span><br><span>Grundy Number 1</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on x" href="https://x.com/intent/tweet/?text=Ps_20220716&amp;url=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f&amp;title=Ps_20220716&amp;summary=Ps_20220716&amp;source=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f&title=Ps_20220716"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on whatsapp" href="https://api.whatsapp.com/send?text=Ps_20220716%20-%20https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on telegram" href="https://telegram.me/share/url?text=Ps_20220716&amp;url=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Ps_20220716 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Ps_20220716&u=https%3a%2f%2ftamref.github.io%2fposts%2fmigrated%2fps_20220716%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tamref.github.io/>TAMREF's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>